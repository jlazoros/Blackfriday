---
title: "Black Friday"
authors: "Miquel Martorell"
date: "15/01/2019"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**PREGUNTAS**

Trabajo final de tecnología en R (formato markdown):

(Restar 1 Millón y los datos estarán en el rango de 0 y 10 K.)

1.- ¿Qué variables pueden ser factores?

2.- ¿Se venden igual las mismas categorías?

3.- ¿Los usuarios compran el mismo item?

4.- Sistemas de recomendación

5.- ¿Gastan más los hombres o las mujeres?

6.- Gráfico bipartito entre productos y consumidores

7.- Otros: Clustering, proyección de ventas, estimar el gasto futuro, deducir con una serie de datos si el consumidor es hombre o mujer.

8.- Dividir los datos en conjunto de entrenamiento y prueba.

Esta es la lluvia de ideas que se hizo en clase... el profe valora mucho la innovación y que hagas cosas originales que nos guste a nosotros.

**ANÁLISIS DE LOS DATOS BLACK FRIDAY**

Para empezar este análisis procedemos a cargar el conjunto de datos BlackFriday.csv:

```{r}
datos = read.csv("BlackFriday.csv")
```

Importamos las librerías que vamos a utilizar en este análisis de datos:

```{r message=F, warning=F, echo = F}
library(tidyverse)
library(scales)
library(arules)
library(gridExtra)
```

El paquete "tidyverse" es el que usaremos para visualizar y explorar nuestro conjunto de datos. Es conocido por su sintaxis fácil de leer y su gran cantidad de funciones útiles. El paquete "scales" se utilizará principalmente para personalizar el eje del gráfico. *Por último, el paquete "arules"" se utilizará en la parte final del análisis, Association Rule Learning y Apriori.*

Comencemos con una rápida visión general de todo el conjunto de datos:

```{r}
summary(datos)
head(datos)
```

Tenemos 12 columnas diferentes, cada una de las cuales representa una variable, las cuales procedemos a describir a continuación:

* User_ID: Identificador único del comprador.
* Product_ID: Identificador único del producto.
* Gender: Sexo del comprador.
* Age: Edad del comprador.
* Occupation: Ocupación del comprador.
* City_Category: Lugar de residencia del comprador.
* Stay_In_Current_City_Years: Número de años de permanencia en la ciudad actual.
* Marital_Status: Estado civil del comprador.
* Product_Category_1: Categoría 1 de producto de la compra.
* Product_Category_2: Categoría 2 de producto de la compra.
* Product_Category_3: Categoría 3 de producto de la compra.
* Purchase: Importe de la compra en dólares.

Si observamos las primeras filas de nuestro conjunto de datos, podemos ver que cada fila representa una transacción diferente, o un artículo comprado por un cliente específico. Más adelante cuando agrupemos todas las transacciones por un usuario específico obtendremos una suma de todas las compras realizadas por un solo cliente.

Debemos recalcar que en este conjunto de datos no hay una clave dada con respecto a los diferentes Product_IDs y al ítem que representan. Por ejemplo, no podemos atribuir P00265242 a un elemento fácilmente reconocible. En realidad, nos gustaría tener otro conjunto de datos que proporcione el nombre de un elemento y su Product_ID y luego unirlo a nuestro conjunto de datos existente. *Esto no afectará necesariamente a nuestro análisis, pero sería más útil durante nuestra implementación del algoritmo Apriori y podría hacer que algunas partes de la EDA sean más claras de interpretar.*

**Género**

Para empezar nuestro análisis, vamos a examinar el género de los compradores en esta tienda. Dado que cada fila representa una transacción individual, primero debemos agrupar los datos por User_ID para eliminar los duplicados:

```{r}
datos_gender = datos %>%
               select(User_ID, Gender) %>%
               group_by(User_ID) %>%
               distinct()
head(datos_gender)
summary(datos_gender$Gender)
```

Ahora tenemos el conjunto de datos correctamente filtrado para ver el género de cada User_ID y sus totales como referencia. Procedemos a realizar un gráfico el cual representa la distribución de género a través de nuestro conjunto de datos:

```{r}
options(scipen=10000)   # Para eliminar la numeración científica.
gender_dist  = ggplot(data = datos_gender) +
               geom_bar(mapping = aes(x = Gender, y = ..count.., fill = Gender)) +
               labs(title = 'Género Clientes') + 
               scale_fill_brewer(palette = 'PuBuGn')
print(gender_dist)
```

Como podemos ver, hay bastantes más hombres que mujeres comprando en el Black Friday. Esta sencilla división de género podría ser útil para los minoristas porque algunos podrían querer modificar el diseño de su tienda, la selección de productos y otras variables de manera diferente dependiendo del porcentaje de género de sus compradores.  

Para realizar un análisis más profundo, calculemos el importe promedio de gasto en relación al género. Para facilitar la interpretación y el seguimiento, crearemos tablas separadas y luego las uniremos:

```{r}
total_purchase_user = datos %>%
                      select(User_ID, Gender, Purchase) %>%
                      group_by(User_ID) %>%
                      arrange(User_ID) %>%
                      summarise(Total_Purchase = sum(Purchase))
user_gender = datos %>%
              select(User_ID, Gender) %>%
              group_by(User_ID) %>%
              arrange(User_ID) %>%
              distinct()
head(user_gender)
head(total_purchase_user)
```

```{r}
user_purchase_gender = full_join(total_purchase_user, user_gender, by = "User_ID")
head(user_purchase_gender)
```

```{r}
average_spending_gender = user_purchase_gender %>%
                          group_by(Gender) %>%
                          summarize(Purchase = sum(as.numeric(Total_Purchase)), 
                                    Count = n(), 
                                    Average = Purchase/Count)
head(average_spending_gender)
```

Podemos ver que el promedio de transacciones para las mujeres fue de 699.054,00 y el promedio de transacciones para los hombres fue de 911.963,20. Visualicemos nuestros resultados.

```{r}
gender_average  = ggplot(data = average_spending_gender) +
                         geom_bar(mapping = aes(x = Gender, y = Average, fill = Gender), stat = 'identity') +
                         labs(title = 'Gasto Promedio Por género') +
                         scale_fill_brewer(palette = 'PuBuGn')
print(gender_average)
```

Aquí podemos ver una observación interesante. Aunque las mujeres hacen menos compras que los hombres, parecen estar comprando casi tanto en promedio como los hombres. Dicho esto, hay que tener en cuenta la escala, ya que las mujeres siguen gastando en promedio unos 250.000 dólares menos que los hombres.

**Top Vendedores**

Now lets switch gears and examine our top selling products. In this situation, we won't group by product ID since we want to see duplicates, just in case people are buying 2 or more quantities of the same product.

```{r}
top_sellers = datos %>%
              count(Product_ID, sort = TRUE)
top_5 = head(top_sellers, 5)
top_5
```

Looks like our top 5 best sellers are (by product ID)

* P00265242 = 1858
* P00110742 = 1591
* P00025442 = 1586
* P00112142 = 1539
* P00057642 = 1430

Now that we have Identified our top 5 best selling products, lets examine the best selling product, P00265242.

```{r}
best_seller = datos[datos$Product_ID == 'P00265242', ]
head(best_seller)
```

We can see that this product fits into Product_Category_1 = 5 and Product_Category_2 = 8. As mentioned in the introduction, it would be useful to have a key to reference the item name in order to determine what it is.

Another interesting finding is that even though people are purchasing the same product, they are paying different prices. This could be due to various Black Friday promotions, discounts, or coupon codes. Otherwise, investigation would need to be done regarding the reason for different purchase prices of the same product between customers.

Lets continue to analyze our best seller to see if any relationship to Gender exits.

```{r}
gender_dist_bs  = ggplot(data = best_seller) +
                 geom_bar(mapping = aes(x = Gender, y = ..count.., fill = Gender)) +
                 labs(title = 'Gender of Customers (Best Seller)') +
                 scale_fill_brewer(palette = 'PuBuGn')
print(gender_dist_bs)
```

We see a similar distribution between genders to our overall datos gender split - lets confirm.

```{r}
gender_dist_bs_prop = ggplot(data = best_seller) + 
                            geom_bar(fill = 'lightblue', mapping = aes(x = Gender, y = ..prop.., group = 1, fill = Gender)) +
                            labs(title = 'Gender of Customers (Best Seller - Proportion)') +
                            theme(plot.title = element_text(size=9.5))
gender_dist_prop = ggplot(data = datos_gender) + 
                         geom_bar(fill = "lightblue4", mapping = aes(x = Gender, y = ..prop.., group = 1)) +
                         labs(title = 'Gender of Customers (Total Proportion)') +
                         theme(plot.title = element_text(size=9.5)) 
grid.arrange(gender_dist_prop, gender_dist_bs_prop, ncol=2)
```

We can see that between the overall observation set, both purchasers of the best seller and purchasers of all products are roughly ~25% female and ~75% male. A slight difference does exist but it seems like we can generally conclude that our best seller does not cater to a specific gender.

Now, let's move on and examine the Age variable.

**Age**

Lets begin examining Age by creating a table of each individual age group and their respective counts.

```{r}
customers_age = datos %>%
                select(User_ID, Age) %>%
                distinct() %>%
                count(Age)
customers_age
```

Here, we can see a datos that shows the count of each Age category of customers at our store. Lets visualize this table.

```{r}
customers_age_vis = ggplot(data = customers_age) + 
                           geom_bar(color = 'black', stat = 'identity', mapping = aes(x = Age, y = n, fill = Age)) +
                           labs(title = 'Age of Customers') +
                           theme(axis.text.x = element_text(size = 10)) +
                           scale_fill_brewer(palette = 'Blues') +
                           theme(legend.position="none")
print(customers_age_vis)
```

We can also plot a similar chart depicting the distribution of age within our "best seller" category. This will show us if there is a specific age category that purchased the best selling product more than other shoppers.

```{r}
ageDist_bs  = ggplot(data = best_seller) +
                     geom_bar(color = 'black', mapping = aes(x = Age, y = ..count.., fill = Age)) +
                     labs(title = 'Age of Customers (Best Seller)') +
                     theme(axis.text.x = element_text(size = 10)) +
                     scale_fill_brewer(palette = 'GnBu') + 
                     theme(legend.position="none")
print(ageDist_bs)
```

It seems as though younger people (18-25 & 26-35) account for the highest number of purchases of the best selling product. Lets compare this observation to the overall datos.

```{r}
grid.arrange(customers_age_vis, ageDist_bs, ncol=2)
```

We can see that there is some deviation with the proportion of customers grouped by age when comparing the best selling product to the overall datos. It looks like older customers > Age 45 are buying the top seller slightly less than other products included in the overall datos.

Now that we have examined age, lets move to another variable.

**City**

Let's create a table of each User_ID and their corresponding City_Category.

```{r}
customers_location =  datos %>%
                      select(User_ID, City_Category) %>%
                      distinct()
head(customers_location)
```

```{r}
customers_location_vis = ggplot(data = customers_location) +
                                geom_bar(color = 'white', mapping = aes(x = City_Category, y = ..count.., fill = City_Category)) +
                                labs(title = 'Location of Customers') + 
                                scale_fill_brewer(palette = "Dark2") + 
                                theme(legend.position="none")
print(customers_location_vis)
```

We can see that most of our customers live in City C. Now, we can compute the total purchase amount by City to see the which city's customers spent the most at our store.

```{r}
purchases_city = datos %>%
                 group_by(City_Category) %>%
                 summarise(Purchases = sum(Purchase))
purchases_city_1000s = purchases_city %>%
                       mutate(purchasesThousands = purchases_city$Purchases / 1000)
purchases_city_1000s
```

In order to work with larger numbers, we divided the Purchases column/1000. This is a common practice within the business and acounting world, and it makes large numbers easier to read and chart.

Now that we have our table, lets visualize our results.

```{r}
purchaseCity_vis = ggplot(data = purchases_city_1000s, aes(x = City_Category, y = purchasesThousands, fill = City_Category)) +
                          geom_bar(color = 'white', stat = 'identity') +
                          labs(title = 'Total Customer Purchase Amount (by City)', y = '($000s)', x = 'City Category') +
                          scale_fill_brewer(palette = "Dark2") + 
                          theme(legend.position="none", plot.title = element_text(size = 9))
print(purchaseCity_vis)
```

```{r}
grid.arrange(customers_location_vis, purchaseCity_vis, ncol=2)
```

Here we can see that customers from City C were the most frequent shoppers at our store on Black Friday but Customers from City B had the highest amount of total purchases.

Let's continue to investigate and try to determine the reason for this observation.

Lets find how many purchases were made by customers from each city. First, we will get the total number of purchases for each corresponding User_ID.

```{r}
customers = datos %>%
            group_by(User_ID) %>%
            count(User_ID)
head(customers)
```

This tells us how many times a certain user made a purchase. To dive deeper lets compute the total purchase amount for each user, then join it with the other table

```{r}
customers_City =  datos %>%
                  select(User_ID, City_Category) %>%
                  group_by(User_ID) %>%
                  distinct() %>%
                  ungroup() %>%
                  left_join(customers, customers_City, by = 'User_ID') 
head(customers_City)
city_purchases_count = customers_City %>%
                       select(City_Category, n) %>%
                       group_by(City_Category) %>%
                       summarise(CountOfPurchases = sum(n))
city_purchases_count
```

```{r}
city_count_purchases_vis = ggplot(data = city_purchases_count, aes(x = City_Category, y = CountOfPurchases, fill = City_Category)) +
                           geom_bar(color = 'white', stat = 'identity') +
                           labs(title = 'Total Purchase Count (by City)', y = 'Count', x = 'City Category') +
                           scale_fill_brewer(palette = "Dark2") +
                           theme(legend.position="none", plot.title = element_text(size = 9))
print(city_count_purchases_vis)
```

```{r}
grid.arrange(purchaseCity_vis, city_count_purchases_vis, ncol = 2)
```

One inference we can make from these charts is that customers from City B are simply making more purchases than residence of City A + City C, and not necessarily buying more expensive products. We can make this assumption due to the fact that the "Total Count of Purchases" chart has a very similar appearance to the "Total Customer Purchase Amount" chart. If it were the other case, then customers from City B would most likely have a lower count of total purchases corresponding to a higher total purchase amount.

Now, since we have identified that the purchase counts across City_Category follow a similar distribution to total purchase amount, lets examine the distribution of our best selling product (P00265242) within each City_Category.

```{r}
head(best_seller)
best_seller_city = best_seller %>%
                   select(User_ID, City_Category) %>%
                   distinct() %>%
                   count(City_Category)
best_seller_city
```

```{r}
best_seller_city_vis = ggplot(data = best_seller_city, aes(x = City_Category, y = n, fill = City_Category)) +
                              geom_bar(color = 'white', stat = 'identity') +
                              labs(title = 'Best Seller Purchase Count (by City)', y = 'Count', x = 'City Category') +
                              scale_fill_brewer(palette = "Blues") +
                              theme(legend.position="none", plot.title = element_text(size = 9))
grid.arrange(city_count_purchases_vis,best_seller_city_vis, ncol = 2)
```

An interesting revelation has been made! Although customers residing in City C purchase more of our "best seller" than City A + B, residents of City C fall behind City B in overall number of purchases.

**Stay in Current City**

Lets now examine the distribution of customers who have lived in their city the longest.

```{r}
customers_stay = datos %>%
                 select(User_ID, City_Category, Stay_In_Current_City_Years) %>%
                 group_by(User_ID) %>%
                 distinct()
head(customers_stay)
```

Now that we have our datos in order, we can plot and explore.

Lets see where most of our customers are living.

```{r}
residence = customers_stay %>%
            group_by(City_Category) %>%
            tally()
head(residence)
```

Looks like most of our customers are living in City C. Now, lets investigate further.

```{r}
customers_stay_vis = ggplot(data = customers_stay, aes(x = Stay_In_Current_City_Years, y = ..count.., fill = Stay_In_Current_City_Years)) +
                            geom_bar(stat = 'count') +
                            scale_fill_brewer(palette = 15) +
                            labs(title = 'Customers Stay in Current City', y = 'Count', x = 'Stay in Current City', fill = 'Number of Years in Current City')
print(customers_stay_vis)
```

It looks like most of our customers have only been living in their respective cities for 1 year. In order to see a better distribution, lets make a stacked bar chart according to each City_Category.

```{r}
stay_cities = customers_stay %>%
              group_by(City_Category, Stay_In_Current_City_Years) %>%
              tally() %>%
              mutate(Percentage = (n/sum(n))*100)
head(stay_cities)
```

```{r}
ggplot(data = stay_cities, aes(x = City_Category, y = n, fill = Stay_In_Current_City_Years)) + 
       geom_bar(stat = "identity", color = 'white') + 
       scale_fill_brewer(palette = 2) + 
       labs(title = "City Category + Stay in Current City", 
            y = "Total Count (Years)", 
            x = "City", 
            fill = "Stay Years")
```

Looking at this chart we can see the distribution of the total customer base and their respective city residences, split by the amount of time they have lived there. Here, we can notice that in every City_Category, the most common stay length seems to be 1 year.

**Purchase**

Now lets do some investigation regarding store customers and their purchases. We will start by computing the total purchase amount by user ID

```{r}
customers_total_purchase_amount = datos %>%
                                  group_by(User_ID) %>%
                                  summarise(Purchase_Amount = sum(Purchase))
head(customers_total_purchase_amount)
```

Now that we have grouped our purchases and grouped by User ID, we will sort and find our top spenders.

```{r}
customers_total_purchase_amount = arrange(customers_total_purchase_amount, desc((Purchase_Amount)))
head(customers_total_purchase_amount)
```

Looks like User ID 1004277 is our top spender. Lets use summary() to see other facets of our total customer spending data.

```{r}
summary(customers_total_purchase_amount)
```

We can see an average total purchase amount of 851752, max total purchase amount of 10536783, min total purchase amount of 44108 and a median purchase amount of 512612.

Lets plot a chart showing the distribution of purchase amounts to see if purchases are normally distributed or contain some skewness. A density plot will show us where the highest number of similar purchase amounts rests in accordance to the entire customer base. It is important to note that Density charts graph the expected probability of values, given data as input, and then plot a line surrounding those values (estimation).

```{r}
ggplot(customers_total_purchase_amount, aes(Purchase_Amount)) +
       geom_density(adjust = 1) +
       geom_vline(aes(xintercept=median(Purchase_Amount)),
                  color="blue", linetype="dashed", size=1) +
       geom_vline(aes(xintercept=mean(Purchase_Amount)),
                  color="red", linetype="dashed", size=1) +
       geom_text(aes(x=mean(Purchase_Amount), label=round(mean(Purchase_Amount)), y=1.2e-06), color = 'red', angle=360, size=4, vjust=3, hjust=-.1) +
       geom_text(aes(x=median(Purchase_Amount), label=round(median(Purchase_Amount)), y=1.2e-06), color = 'blue', angle=360,msize=4, vjust=0, hjust=-.1) +
       scale_x_continuous(name="Purchase Amount", limits=c(0, 7500000), breaks = seq(0,7500000, by = 1000000), expand = c(0,0)) +
       scale_y_continuous(name="Density", limits=c(0, .00000125), labels = scientific, expand = c(0,0))
```

Here we are seeing a very right (positive) skewed density plot with a long tail. This means that there are quite a few values that sit higher than the mean and that the highest density of values isn't a standardly distributed series. We see that the largest density of purchases is around the 250000 mark.

**Marital Status**

Lets now examine the marital status of store customers.

```{r}
datos_maritalStatus = datos %>%
                        select(User_ID, Marital_Status) %>%
                        group_by(User_ID) %>%
                        distinct()
head(datos_maritalStatus)
```

Note, we need to quickly change Marital_Status from a numeric variable to a categorical type.

```{r}
datos_maritalStatus$Marital_Status = as.character(datos_maritalStatus$Marital_Status)
typeof(datos_maritalStatus$Marital_Status)
```

If we look back at the variable descriptions of the datos, we don't have a clear guide for marital status. In other cases, it would be best to reach out to the provider of the data to be completely sure of what the values in a column represent but in this case, we will assume that 1 = married and 0 = single.

```{r}
marital_vis = ggplot(data = datos_maritalStatus) +
                     geom_bar(mapping = aes(x = Marital_Status, y = ..count.., fill = Marital_Status)) +
                     labs(title = 'Marital Status') +
                     scale_fill_brewer(palette = 'Pastel2')
print(marital_vis)
```

It looks like most of our shoppers happen to be single or unmarried. Similar to our investigation of age groups, we can look at the makeup of Marital_Status in each City_Category.

```{r}
datos_maritalStatus = datos_maritalStatus %>%
                        full_join(customers_stay, by = 'User_ID') 
head(datos_maritalStatus)
```

```{r}
maritalStatus_cities = datos_maritalStatus %>%
                       group_by(City_Category, Marital_Status) %>%
                       tally()
head(maritalStatus_cities)
```

```{r}
ggplot(data = maritalStatus_cities, aes(x = City_Category, y = n, fill = Marital_Status)) + 
       geom_bar(stat = "identity", color = 'black') + 
       scale_fill_brewer(palette = 2) + 
       labs(title = "City + Marital Status", 
            y = "Total Count (Shoppers)", 
            x = "City", 
            fill = "Marital Status")
```

Here, we can see that out off all Cities, the highest proportion of single shoppers seems to be in City A. Now, lets investigate the Stay_in_Current_City distribution within each City_Category.

```{r}
Users_Age = datos %>%
            select(User_ID, Age) %>%
            distinct()
head(Users_Age)
```

```{r}
datos_maritalStatus = datos_maritalStatus %>%
                        full_join(Users_Age, by = 'User_ID')
head(datos_maritalStatus)
```

```{r}
City_A = datos_maritalStatus %>%
         filter(City_Category == 'A')
City_B = datos_maritalStatus %>%
         filter(City_Category == 'B')
City_C = datos_maritalStatus %>%
         filter(City_Category == 'C')
head(City_A)
head(City_B)
head(City_C)
```

```{r}
City_A_stay_vis = ggplot(data = City_A, aes(x = Age, y = ..count.., fill = Age)) + 
                         geom_bar(stat = 'count') +
                         scale_fill_brewer(palette = 8) +
                         theme(legend.position="none", axis.text = element_text(size = 6)) +
                         labs(title = 'City A', y = 'Count', x = 'Age', fill = 'Age')
City_B_stay_vis = ggplot(data = City_B, aes(x = Age, y = ..count.., fill = Age)) +
                         geom_bar(stat = 'count') +
                         scale_fill_brewer(palette = 9) +
                         theme(legend.position="none", axis.text = element_text(size = 6)) +
                         labs(title = 'City B', y = 'Count', x = 'Age', fill = 'Age')
City_C_stay_vis = ggplot(data = City_C, aes(x = Age, y = ..count.., fill = Age)) +
                         geom_bar(stat = 'count') +
                         scale_fill_brewer(palette = 11) +
                         theme(legend.position="none", axis.text = element_text(size = 6)) +
                         labs(title = 'City C', y = 'Count', x = 'Age', fill = 'Age')
grid.arrange(City_A_stay_vis, City_B_stay_vis, City_C_stay_vis, ncol = 3)
```

It looks as though City A has less shoppers living there over the age of 45 compared to the other cities. This could be a factor in the resulting levels of Marital_Status within each individual city.

**Top Shoppers**

Now, we will investigate who our top shoppers were on Black Friday.

```{r}
top_shoppers = datos %>%
               count(User_ID, sort = TRUE)
head(top_shoppers)
```

Looks like User_ID 1001680 shows up the most on our master ledger of shopper data. Since each individual row represents a different transaction/product, it looks like this user made over 1000 total transactions! We can join together this top shoppers datos with our total customer purchases datos to see them combined.

```{r}
top_shoppers =  top_shoppers %>%
                select(User_ID, n) %>%
                left_join(customers_total_purchase_amount, Purchase_Amount, by = 'User_ID')
head(top_shoppers)
```

Now that we have joined the two tables together, we can see that although User_ID 1001680 has the highest number of total purchases, User_ID 1004277 has the highest Purchase_Amount as identified in our earlier charts as well. From here, we can also compute the average Purchase_Amount for each user.

```{r}
top_shoppers = mutate(top_shoppers,
               Average_Purchase_Amount = Purchase_Amount/n)
head(top_shoppers)
```

Now, we can sort according to Average_Purchase_Amount to see which customers, on average, are spending the most.

```{r}
top_shoppers_averagePurchase = top_shoppers %>%
                               arrange(desc(Average_Purchase_Amount))
head(top_shoppers_averagePurchase)
```

Looks like User_ID 1005069 has the highest Average_Purchase_Amount and a total Purchase_Amount of 308454. User_ID 1003902 is right behind User_ID 1005069 in Average_Purchase_Amount, but has a much higher total Purchase_Amount of 1746284.

**Occupation**

The last thing we will analyze is the occupation of customers in our datos.

```{r}
customers_Occupation =  datos %>%
                        select(User_ID, Occupation) %>%
                        group_by(User_ID) %>%
                        distinct() %>%
                        left_join(customers_total_purchase_amount, Occupation, by = 'User_ID')
head(customers_Occupation)
```

Now that we have our datos necessary, we can group together the total Purchase_Amount for each Occupation identifier. We will then convert Occupation to a charater data type.

```{r}
totalPurchases_Occupation = customers_Occupation %>%
                            group_by(Occupation) %>%
                            summarise(Purchase_Amount = sum(Purchase_Amount)) %>%
                            arrange(desc(Purchase_Amount))
totalPurchases_Occupation$Occupation = as.character(totalPurchases_Occupation$Occupation)
typeof(totalPurchases_Occupation$Occupation)
head(totalPurchases_Occupation)
```

Now, lets plot each occupation and their total Purchase_Amount

```{r}
occupation = ggplot(data = totalPurchases_Occupation) +
                    geom_bar(mapping = aes(x = reorder(Occupation, -Purchase_Amount), y = Purchase_Amount, fill = Occupation), stat = 'identity') +
                    scale_x_discrete(name="Occupation", breaks = seq(0,20, by = 1), expand = c(0,0)) +
                    scale_y_continuous(name="Purchase Amount ($)", expand = c(0,0), limits = c(0, 750000000)) +
                    labs(title = 'Total Purchase Amount by Occupation') + 
                    theme(legend.position="none")
print(occupation)
```

Looks like customers labeled as Occupation 4 spent the most at our store on Black Friday, with customers of Occupation 0 + 7 closely behind. Here, if a key was given, we could use that information to classify our shoppers accordingly.

